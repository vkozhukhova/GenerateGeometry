## -*- encoding: utf-8 -*-
## This file (geom_tk3.sagetex.sage) was *autogenerated* from geom_tk3.tex with sagetex.sty version 2015/08/26 v3.0-92d9f7a.
import sagetex
_st_ = sagetex.SageTeXProcessor('geom_tk3', version='2015/08/26 v3.0-92d9f7a', version_check=True)
_st_.current_tex_line = 73
_st_.blockbegin()
try:
 # генерируем точки М1 и М2
 M1 = vector([randint(-7, 7) for i in range(2)])
 M2 = vector([randint(-4, 4) for i in range(2)])
 # если направляющий вектор нулевой, перегенерируем
 while M1==M2:
  M2 = vector([randint(-4, 4) for i in range(2)])
 # генерируем угол альфа
 S3 = FiniteEnumeratedSet([30,45,60,90,135,120,150]) # углы в градусах
 ang = S3.random_element() # случайный угол
 # направляющий вектор
 M1M2=M2-M1
 var('x,y,t')
 # если в уравнении нет переменной y
 if M1M2[0]==0:
    eqcan=x-M1[0]==0 # каноническое
    eqline=eqcan # общее
    eqparam=eqcan.left()==t
    eqparam=(solve(eqparam,x))[0] # параметрическое
    eqang=eqline # с угловым коэффициентом
    ccoef=-M1[0] # константа в уравнении
    if M1[0]==0:
      eqotr=eqline # в отрезках чтоб не было деления на ноль
    else:
      eqotr=x/M1[0]==1 # в отрезках
 else :
    # если в уравнении нет переменной x
    if M1M2[1]==0:
       eqcan=y-M1[1]==0 # каноническое
       eqline=eqcan # общее
       eqparam=eqcan.left()==t
       eqparam=(solve(eqparam,y))[0] # параметрическое
       eqang=solve(eqline,y)[0] # с угловым коэффициентом
       ccoef=-M1[1] # константа в уравнении
       if M1[1]==0:
         eqotr=eqline  # в отрезках чтоб не было деления на ноль
       else:
         eqotr=y/M1[1]==1 # в отрезках
    else :
       # если в уравнении есть обе переменных x и y
       eqcan=(x-M1[0])/M1M2[0]==(y-M1[1])/M1M2[1] # каноническое
       eqparam=[eqcan.left()==t, eqcan.right()==t]
       eqparam=(solve(eqparam,x,y))[0] # параметрическое
       eqcan2=eqcan.subtract_from_both_sides(eqcan.right())
       eqline=eqcan2.multiply_both_sides(lcm(eqcan.left().denominator(), eqcan.right().denominator())) # общее
       eqang=solve(eqline,y)[0] # с угловым коэффициентом
       # коэффициенты уравнения
       ccoef=eqline.left().coefficient(x,0).coefficient(y,0)
       acoef=eqline.left().coefficient(x,1)
       bcoef=eqline.left().coefficient(y,1)
       # проверка константа в уравнении = 0
       if ccoef==0:
          eqotr=eqline # в отрезках чтоб не было деления на ноль
       else:
          eqotr=x/(-ccoef/acoef)+y/(-ccoef/bcoef)==1 # в отрезках
 # вектор нормали
 nl=vector([eqline.left().coefficient(x,1), eqline.left().coefficient(y,1)])
 # делим на +- длину нормального вектора
 if ccoef>0:
    eqnorm=eqline.divide_both_sides(-nl.norm())
 else:
    eqnorm=eqline.divide_both_sides(nl.norm())
 #  направляющие косинусы
 cosline=vector([eqnorm.left().coefficient(x,1), eqnorm.left().coefficient(y,1)])
 #  прямая через М1 под углом альфа к Ох
 if ang==90:
    eqang2=x==M1[0]
 else:
    eqang2=y-M1[1]==tan(ang*pi/180)*(x-M1[0])
    eqang2=solve(eqang2,y)[0]
 # треугольник АВС
 crossm = zero_matrix(2,2)
 while (det(crossm)==0) or (abs(det(crossm)/2) < 8) :
   A = vector([randint(-7, 7) for i in range(2)])
   B = vector([randint(-4, 4) for i in range(2)])
   C = vector([randint(-10, 10) for i in range(2)])
   AB = B-A
   AC = C-A
   BC = C-B
   crossm = matrix([AB, AC])
 chv=randint(1,3) # первая случайная вершина vertex1
 ch1=randint(1,2) # вторая случайная вершина vertex2
 # присваиваем координаты выбранным вершинам
 if chv == 1 :
  vertex = r"A"
  V1=A
  if ch1==1:
   vertex2=r"B"
   V2=B
   vertex3=r"C"
   V3=C
  else:
   vertex2=r"C"
   V2=C
   vertex3=r"B"
   V3=B
 else :
  if chv == 2 :
   vertex = r"B"
   V1=B
   if ch1==1:
    vertex2=r"A"
    V2=A
    vertex3=r"C"
    V3=C
   else:
    vertex2=r"C"
    V2=C
    vertex3=r"A"
    V3=A
  else :
   vertex = r"C"
   V1=C
   if ch1==1:
    vertex2=r"B"
    V2=B
    vertex3=r"A"
    V3=A
   else:
    vertex2=r"A"
    V2=A
    vertex3=r"B"
    V3=B
 # генерируем L=line2
 a1=0
 b1=0
 c1=0
 # чтобы не было нулевых коэф-в и точки АВС не лежали бы на L
 while (a1==0) or (b1==0) or (c1==0) or (a1*A[0]+b1*A[1]+c1==0) or (a1*B[0]+b1*B[1]+c1==0) or (a1*C[0]+b1*C[1]+c1==0) :
  a1=randint(-10, 10)
  b1=randint(-10, 10)
  c1=randint(-10, 10)
  line2=a1*x+b1*y+c1==0
 # уравнения через вершину параллельно и перпендикулярно line2=L
 nLx=line2.left().coefficient(x,1)
 nLy=line2.left().coefficient(y,1)
 # параллельно
 eqLparal=nLx*(x-V1[0])+nLy*(y-V1[1])==0
 # перпендикулярно
 eqLorthog=(x-V1[0])/nLx-(y-V1[1])/nLy==0
 eqLorthog=eqLorthog.multiply_both_sides(eqLorthog.left().denominator())
 # точка пересечения высот
 # высота через вершину V1
 h1=(V3[0]-V2[0])*(x-V1[0])+(V3[1]-V2[1])*(y-V1[1])==0
 # высота через вершину V2
 h2=(V3[0]-V1[0])*(x-V2[0])+(V3[1]-V1[1])*(y-V2[1])==0
 # точка пересечения высот
 h1h2=solve([h1,h2],x,y)
 hh=vector([h1h2[0][0].right(), h1h2[0][1].right()])
 # длина перпендикуляра из V1 на медиану из V2
 # направляющий вектор медианы
 smedx=(V3[0]+V1[0])/2-V2[0]
 smedy=(V3[1]+V1[1])/2-V2[1]
 # если одна из координат напр. вектора медианы = 0
 if smedx==0:
  vert2med=x-V2[0]==0
  vert1h=(y-V1[1])==0
 else:
  if smedy==0:
   vert2med=y-V2[1]==0
   vert1h=(x-V1[0])==0
  else:
   vert2med=(x-V2[0])/(smedx)-(y-V2[1])/(smedy)==0
   vert1h=(x-V1[0])/vert2med.left().coefficient(x,1)-(y-V1[1])/vert2med.left().coefficient(y,1)==0
 vert2med=vert2med.multiply_both_sides(vert2med.left().denominator())
 vert1h=vert1h.multiply_both_sides(vert1h.left().denominator())
 # точка пересечения медианы и перпендикуляра
 medh=solve([vert2med,vert1h],x,y)
 medh=vector([medh[0][0].right(), medh[0][1].right()])
 # длина перпендикуляра
 perp=(medh-V1).norm()
 # уравнения биссектрис угла между прямыми V1V2 и V1V3
 # V1V2
 V1V2=(x-V1[0])*(V2[1]-V1[1])-(y-V1[1])*(V2[0]-V1[0])==0
 # V1V3
 V1V3=(x-V1[0])*(V3[1]-V1[1])-(y-V1[1])*(V3[0]-V1[0])==0
 # вектор нормали V1V2
 nV1V2=vector([V1V2.left().coefficient(x,1), V1V2.left().coefficient(y,1)])
 # вектор нормали V1V3
 nV1V3=vector([V1V3.left().coefficient(x,1), V1V3.left().coefficient(y,1)])
 # делим на +- длину нормального вектора
 if V1V2.left().coefficient(x,0).coefficient(y,0)>0:
  v1v2norm=V1V2.divide_both_sides(-nV1V2.norm())
 else:
  v1v2norm=V1V2.divide_both_sides(nV1V2.norm())
 if V1V3.left().coefficient(x,0).coefficient(y,0)>0:
  v1v3norm=V1V3.divide_both_sides(-nV1V3.norm())
 else:
  v1v3norm=V1V3.divide_both_sides(nV1V3.norm())
 denom=gcd((nV1V2.norm(),nV1V3.norm()))
 biss1=v1v2norm.left()-v1v3norm.left()
 biss2=v1v2norm.left()+v1v3norm.left()
 biss1=biss1.canonicalize_radical().mul(denom)
 biss2=biss2.canonicalize_radical().mul(denom)
 biss1=biss1.expand().collect(x).collect(y)
 biss2=biss2.expand().collect(x).collect(y)
 biss1=biss1.mul(biss1.denominator())
 biss2=biss2.mul(biss2.denominator())
 if (sign(biss1.subs(x==V2[0],y==V2[1])))==(sign(biss1.subs(x==V3[0],y==V3[1]))):
  bissstr = r"внешнего"
 else:
  bissstr = r"внутреннего"
 # найти точку симметричную V1 относительно V2V3
 # V2V3
 V2V3=(x-V2[0])*(V3[1]-V2[1])-(y-V2[1])*(V3[0]-V2[0])==0
 aV2V3=V2V3.left().coefficient(x,1)
 bV2V3=V2V3.left().coefficient(y,1)
 cV2V3=V2V3.left().coefficient(x,0).coefficient(y,0)
 eq1=bV2V3*(x-V1[0])-aV2V3*(y-V1[1])==0
 eq2=(aV2V3^2+bV2V3^2)*(x-V1[0])+2*aV2V3*(aV2V3*V1[0]+bV2V3*V1[1]+cV2V3)==0
 eq3=(aV2V3^2+bV2V3^2)*(y-V1[1])+2*bV2V3*(aV2V3*V1[0]+bV2V3*V1[1]+cV2V3)==0
 # точкa симметричная V1 относительно V2V3
 pp=vector([solve([eq1,eq2,eq3],x,y)[0][0].right(),solve([eq1,eq2,eq3],x,y)[0][1].right()])
 # график треугольника
 P1 = {'A':A,'B':B,'C':C}
 P2 = {'A':A,'B':B,'C':C, 'H':hh}
 P3 = {'A':A,'B':B,'C':C,'Q':pp}
 # настройка графика - минимум-максимум по отображаемым точкам
 def Min_Max_Values(P) :
     x=vector(QQ,[i for i in range(len(P.values()))])
     y=vector(QQ,[i for i in range(len(P.values()))])
     for i in range(len(P.values())):
         x[i]=P.values()[i][0]
         y[i]=P.values()[i][1]
     xmin=min(x)
     xmax=max(x)
     if sign(xmin) == sign(xmax):
        if sign(xmin)==-1:
           xmax=abs(xmax)
        else :
           if sign(xmin)==0:
              xmin=-10
              xmax=10
           else:
              xmin=-xmin
     ymin=min(y)
     ymax=max(y)
     if sign(ymin) == sign(ymax):
        if sign(ymin)==-1:
           ymax=abs(ymax)
        else :
           if sign(ymin)==0:
              ymin=-10
              ymax=10
           else:
              ymin=-ymin
     res = vector(QQ,[xmin,xmax,ymin,ymax])
     return res
 # min max graph 1-3
 mmg=Min_Max_Values(P1)
 xmin=mmg[0]
 xmax=mmg[1]
 ymin=mmg[2]
 ymax=mmg[3]
 # параллельно и перпендикулярно L
 G1=points(P1.values(), size=50, color='black', figsize=4, aspect_ratio=1, xmin=1.5*xmin, xmax=1.5*xmax, ymin=1.5*ymin, ymax=1.5*ymax)+line((A,B), color='black')+line((A,C), color='black')+line((B,C), color='black')+plot(solve(eqLparal,y)[0].right(), (x,1.5*xmin,1.5*xmax))+plot(solve(eqLorthog,y)[0].right(), (x,1.5*xmin,1.5*xmax)) + plot(solve(line2,y)[0].right(), (x,1.5*xmin,1.5*xmax), color='red', legend_label='L')
 i=0
 for p in P1.keys():
   G1 += text('  %s'%p,P1.values()[i],horizontal_alignment='left',color='black')
   i=i+1
 # высоты и их точка пересечения
 mmg=Min_Max_Values(P2)
 xmin=mmg[0]
 xmax=mmg[1]
 ymin=mmg[2]
 ymax=mmg[3]
 G2=points(P2.values(), size=50, color='black', figsize=4, aspect_ratio=1, xmin=1.5*xmin, xmax=1.5*xmax, ymin=1.5*ymin, ymax=1.5*ymax)+line((A,B), color='black')+line((A,C), color='black')+line((B,C), color='black')+plot(solve(h1,y)[0].right(), (x,1.5*xmin,1.5*xmax), legend_label='h1')+plot(solve(h2,y)[0].right(), (x,1.5*xmin,1.5*xmax), legend_label='h2')
 i=0
 for p in P2.keys():
   G2 += text('  %s'%p,P2.values()[i],horizontal_alignment='left',color='black')
   i=i+1
 # медиана и перпендикуляр
 #G3
 # биссектрисы и симметричная точка
 mmg=Min_Max_Values(P3)
 xmin=mmg[0]
 xmax=mmg[1]
 ymin=mmg[2]
 ymax=mmg[3]
 G4=points(P3.values(), size=50, color='black', figsize=4, aspect_ratio=1, xmin=1.5*xmin, xmax=1.5*xmax, ymin=1.5*ymin, ymax=1.5*ymax)+line((A,B), color='black')+line((A,C), color='black')+line((B,C), color='black')+plot(solve(biss1==0,y)[0].right(), (x,1.5*xmin,1.5*xmax), legend_label='b1')+plot(solve(biss2==0,y)[0].right(), (x,1.5*xmin,1.5*xmax), color='red', legend_label='b2')
 i=0
 for p in P3.keys():
  G4 += text('  %s'%p,P3.values()[i],horizontal_alignment='left',color='black')
  i=i+1
  # генерируем L1 и L2
 a1=0
 b1=0
 c1=0
 while (a1==0) or (b1==0) or (c1==0) :
   a1=randint(-10, 10)
   b1=randint(-10, 10)
   c1=randint(-10, 10)
 lineL1=a1*x+b1*y+c1==0
 a2=0
 b2=0
 c2=0
 # они не должны быть параллельны
 while (a2==0) or (b2==0) or (c2==0) or (a1*b2-a2*b1==0):
   a2=randint(-10, 10)
   b2=randint(-10, 10)
   c2=randint(-10, 10)
 lineL2=a2*x+b2*y+c2==0
 # генерируем N
 N = vector([0,0])
 # он не должен на них лежать
 while (N==vector([0,0])) or (lineL1.left().subs(x==N[0],y==N[1])==0) or (lineL2.left().subs(x==N[0],y==N[1])==0):
    N = vector([randint(-10, 10) for i in range(2)])
 # расстояние d
 d=randint(1, 10)
 # K - точка пересечения L1 и L2
 K=vector([solve([lineL1,lineL2],x,y)[0][0].right(),solve([lineL1,lineL2],x,y)[0][1].right()])
 # N - середина KM, находим M
 M=vector([2*N[0]-K[0],2*N[1]-K[1]])
 # сторона парал-ма L3 - через M // L1
 lineL3=a1*(x-M[0])+b1*(y-M[1])==0
 # сторона парал-ма L4 - через M // L3
 lineL4=a2*(x-M[0])+b2*(y-M[1])==0
 # диагональ d1 =KM
 lined1=(x-K[0])*(M[1]-K[1])-(y-K[1])*(M[0]-K[0])==0
 lined1=lined1.multiply_both_sides(lined1.left().denominator())
 lined1=lined1.divide_both_sides(gcd((lined1.left().coefficient(x,1), lined1.left().coefficient(y,1), lined1.left().coefficient(x,0).coefficient(y,0))))
 # R - точка пересечения L1 и L4
 R=vector([solve([lineL1,lineL4],x,y)[0][0].right(),solve([lineL1,lineL4],x,y)[0][1].right()])
 # диагональ d2 = NR
 lined2=(x-N[0])*(R[1]-N[1])-(y-N[1])*(R[0]-N[0])==0
 lined2=lined2.multiply_both_sides(lined2.left().denominator())
 lined2=lined2.divide_both_sides(gcd((lined2.left().coefficient(x,1), lined2.left().coefficient(y,1), lined2.left().coefficient(x,0).coefficient(y,0))))
 # через N перпендикулярно L1 = сторона NE
 lineNE=(x-N[0])*b1-(y-N[1])*a1==0
 lineNE=lineNE.multiply_both_sides(lineNE.left().denominator())
 lineNE=lineNE.divide_both_sides(gcd((lineNE.left().coefficient(x,1), lineNE.left().coefficient(y,1), lineNE.left().coefficient(x,0).coefficient(y,0))))
 # через N перпендикулярно L2 = сторона NF
 lineNF=(x-N[0])*b2-(y-N[1])*a2==0
 lineNF=lineNF.multiply_both_sides(lineNF.left().denominator())
 lineNF=lineNF.divide_both_sides(gcd((lineNF.left().coefficient(x,1), lineNF.left().coefficient(y,1), lineNF.left().coefficient(x,0).coefficient(y,0))))
 # E - точка пересечения L2 и NE
 E=vector([solve([lineL2,lineNE],x,y)[0][0].right(),solve([lineL2,lineNE],x,y)[0][1].right()])
 # F - точка пересечения L1 и NF
 F=vector([solve([lineL1,lineNF],x,y)[0][0].right(),solve([lineL1,lineNF],x,y)[0][1].right()])
 # сторона EF
 lineEF=(x-E[0])*(F[1]-E[1])-(y-E[1])*(F[0]-E[0])==0
 lineEF=lineEF.multiply_both_sides(lineEF.left().denominator())
 lineEF=lineEF.divide_both_sides(gcd((lineEF.left().coefficient(x,1), lineEF.left().coefficient(y,1), lineEF.left().coefficient(x,0).coefficient(y,0))))
 # для графика
 l1G=solve(lineL1,y)[0].right()
 l2G=solve(lineL2,y)[0].right()
 lNEG=solve(lineNE,y)[0].right()
 lNFG=solve(lineNF,y)[0].right()
 lEFG=solve(lineEF,y)[0].right()
 # график этих прямых и точек N, E, F
 P4 = {'N':N,'E':E,'F':F}
 mmg=Min_Max_Values(P4)
 xmin=mmg[0]
 xmax=mmg[1]
 ymin=mmg[2]
 ymax=mmg[3]
 G5=plot(l1G, (x,1.5*xmin,1.5*xmax), thickness=0.5, color='red', ymin=1.5*ymin, ymax=1.5*ymax, figsize=4, aspect_ratio=1, legend_label='L1') + plot(l2G, (x,1.5*xmin,1.5*xmax), thickness=0.5, color='green', ymin=1.5*ymin, ymax=1.5*ymax, legend_label='L2') + plot(lNEG, (x,1.5*xmin,1.5*xmax), thickness=0.5, color='black', ymin=1.5*ymin, ymax=1.5*ymax) + plot(lNFG, (x,1.5*xmin,1.5*xmax), thickness=0.5, color='black',ymin=1.5*ymin, ymax=1.5*ymax)+plot(lEFG, (x,1.5*xmin,1.5*xmax), thickness=0.5, color='black', ymin=1.5*ymin, ymax=1.5*ymax)+ points(P4.values(), color='black', ymin=1.5*ymin, ymax=1.5*ymax, xmin=1.5*xmin, xmax=1.5*xmax)
 i=0
 for p in P4.keys():
   G5 += text('  %s'%p,P4.values()[i],horizontal_alignment='left',color='black')
   i=i+1
 # расстояние от точки N до прямой L1
 # вектор нормали
 nl1=vector([a1, b1])
 # делим на +- длину нормального вектора
 if c1>0:
   lineL1norm=lineL1.divide_both_sides(-nl1.norm())
 else:
   lineL1norm=lineL1.divide_both_sides(nl1.norm())
 # расстояние
 dNL1=abs(lineL1norm.left().subs(x==N[0], y==N[1]))
 # вектор нормали
 nl2=vector([a2, b2])
 # делим на +- длину нормального вектора
 if c2>0:
   lineL2norm=lineL2.divide_both_sides(-nl2.norm())
 else:
   lineL2norm=lineL2.divide_both_sides(nl2.norm())
 if sign(lineL2norm.left().subs(x==N[0], y==N[1])) == sign(lineL2norm.left().subs(x==0, y==0)):
   intercept=r"не"
 else:
   intercept=r""
 # уравнения прямых паралелльных L1
 var('cc')
 newL=a1*x+b1*y+cc==0
 newLNorm=newL.divide_both_sides(sqrt(a1^2+b1^2))
 U=vector([0,solve(lineL1.subs(x==0),y)[0].right()])
 eq1=newLNorm.left().subs(x==U[0],y==U[1])==d
 eq2=newLNorm.left().subs(x==U[0],y==U[1])==-d
 cc1=solve(eq1,cc)[0].right()
 cc2=solve(eq2,cc)[0].right()
 G6=plot(solve(lineL1,y)[0].right(), (x,-10,10), aspect_ratio=1, color='red', figsize=4)+plot(solve(newL(cc=cc1),y)[0].right(), (x,-10,10), aspect_ratio=1, figsize=4)+plot(solve(newL(cc=cc2),y)[0].right(), (x,-10,10), aspect_ratio=1, figsize=4)
 # квадрат
 # сторона Lp через N перпендикулярно L1 ( = NE)
 lineLp=lineNE
 ap=lineLp.left().coefficient(x,1)
 bp=lineLp.left().coefficient(y,1)
 # сторона Lq через N параллельно L1
 lineLq=a1*(x-N[0])+b1*(y-N[1])==0
 # стороны Lr и Lt параллельно Lp на расстоянии dNL1
 lineLrt=ap*x+bp*y+cc==0
 lineLrtNorm=lineLrt.divide_both_sides(sqrt(ap^2+bp^2))
 eq1=lineLrtNorm.left().subs(x==N[0],y==N[1])==dNL1
 eq2=lineLrtNorm.left().subs(x==N[0],y==N[1])==-dNL1
 cc3=solve(eq1,cc)[0].right()
 cc4=solve(eq2,cc)[0].right()
 G7=plot(solve(lineL1,y)[0].right(), (x,-15,15), aspect_ratio=1, color='red', figsize=4, legend_label='L1', ymin=-20, ymax=20)+plot(solve(lineLrt(cc=cc3),y)[0].right(), (x,-10,10), aspect_ratio=1, figsize=4)+plot(solve(lineLrt(cc=cc4),y)[0].right(), (x,-10,10), aspect_ratio=1, figsize=4)+plot(solve(lineLp,y)[0].right(), (x,-10,10), aspect_ratio=1, color='green', figsize=4)+plot(solve(lineLq,y)[0].right(), (x,-10,10), aspect_ratio=1, color='purple', figsize=4)+ point(N, color='black', xmin=-10, xmax=10)+text('  N',N,horizontal_alignment='left',color='black')
 # угол между прямыми
 angL1L2=arccos(abs(nl1.dot_product(nl2)/(nl1.norm()*nl2.norm())))
 # отклонения точек O и N от L1 и L2
 deltaOL1=lineL1norm.left().subs(x==0,y==0)
 deltaOL2=lineL2norm.left().subs(x==0,y==0)
 deltaNL1=lineL1norm.left().subs(x==N[0],y==N[1])
 deltaNL2=lineL2norm.left().subs(x==N[0],y==N[1])
 # angO = 1 если O в остром углу и = 2 если в тупом
 n1orient=vector([lineL1norm.left().coefficient(x,1), lineL1norm.left().coefficient(y,1)])
 n2orient=vector([lineL2norm.left().coefficient(x,1), lineL2norm.left().coefficient(y,1)])
 if n1orient.dot_product(n2orient)>0:
    angO = -1 # в тупом
 else:
    angO = 1 # в остром, в т.ч. в прямом
 # взаимное расположение O и N
 if (sign(deltaOL1)==-sign(deltaNL1)) and (sign(deltaOL2)==-sign(deltaNL2)):
    angON = 1 # вертикальные углы
    angN = angO # вертикальные углы
 else:
    if (sign(deltaOL1)==sign(deltaNL1)) and (sign(deltaOL2)==sign(deltaNL2)):
       angON = 2 # один и тот же угол
       angN = angO
    else:
       angON = 3 # смежные углы
       angN = -angO
 if angN==1:
    angNstr=r"остром"
 else:
    angNstr=r"тупом"
 if angON==1:
    angONstr=r"вертикальном"
 else:
    if angON==2:
       angONstr=r"одном"
    else:
       angONstr=r"смежном"
 # уравнения биссектрис угла между прямыми L1 и L2
 denom=gcd((nl1.norm(),nl2.norm()))
 biss3=lineL1norm.left()-lineL2norm.left()
 biss4=lineL1norm.left()+lineL2norm.left()
 biss3=biss3.canonicalize_radical().mul(denom)
 biss4=biss4.canonicalize_radical().mul(denom)
 biss3=biss3.expand().collect(x).collect(y)
 biss4=biss4.expand().collect(x).collect(y)
 biss3=biss3.mul(biss3.denominator())
 biss4=biss4.mul(biss4.denominator())
 G8=plot(l1G, (x,-10,10), color='red', figsize=4, aspect_ratio=1, legend_label='L1', ymin=-15, ymax=15) + plot(l2G, (x,-10,10), color='green', legend_label='L2') + plot(solve(biss3==0,y)[0].right(), (x,-10,10), legend_label='b1') + plot(solve(biss4==0,y)[0].right(), (x,-10,10), color='black', legend_label='b2')+ point(N, color='black', xmin=-10, xmax=10)+text('  N',N,horizontal_alignment='left',color='black')
except:
 _st_.goboom(527)
_st_.blockend()
try:
 _st_.current_tex_line = 548
 _st_.inline(0, latex(M1))
except:
 _st_.goboom(548)
try:
 _st_.current_tex_line = 548
 _st_.inline(1, latex(M2))
except:
 _st_.goboom(548)
try:
 _st_.current_tex_line = 548
 _st_.inline(2, latex(ang))
except:
 _st_.goboom(548)
try:
 _st_.current_tex_line = 575
 _st_.inline(3, latex(A))
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(4, latex(B))
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(5, latex(C))
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(6, latex(line2))
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(7, vertex)
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(8, vertex)
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(9, vertex)
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 575
 _st_.inline(10, vertex2)
except:
 _st_.goboom(575)
try:
 _st_.current_tex_line = 597
 _st_.inline(11, vertex)
except:
 _st_.goboom(597)
try:
 _st_.current_tex_line = 597
 _st_.inline(12, vertex)
except:
 _st_.goboom(597)
try:
 _st_.current_tex_line = 597
 _st_.inline(13, vertex2)
except:
 _st_.goboom(597)
try:
 _st_.current_tex_line = 597
 _st_.inline(14, vertex3)
except:
 _st_.goboom(597)
try:
 _st_.current_tex_line = 620
 _st_.inline(15, latex(N))
except:
 _st_.goboom(620)
try:
 _st_.current_tex_line = 620
 _st_.inline(16, latex(lineL1))
except:
 _st_.goboom(620)
try:
 _st_.current_tex_line = 620
 _st_.inline(17, latex(lineL2))
except:
 _st_.goboom(620)
try:
 _st_.current_tex_line = 647
 _st_.inline(18, latex(d))
except:
 _st_.goboom(647)
try:
 _st_.current_tex_line = 674
 _st_.inline(19, latex(eqang2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(20, latex(eqline))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(21, latex(M1M2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(22, latex(x-M1[0]))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(23, latex(M1M2[0]))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(24, latex(y-M1[1]))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(25, latex(M1M2[1]))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(26, latex(eqparam))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(27, latex(eqang))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(28, latex(eqotr))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(29, latex(eqnorm))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(30, latex(cosline))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(0, format='notprovided', _p_=G1)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(1, format='notprovided', _p_=G2)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(31, latex(eqLparal))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(32, latex(eqLorthog))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(33, latex(h1))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(34, latex(h2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(35, latex(h1h2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(36, latex(vert2med))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(37, latex(vert1h))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(38, latex(perp))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(39, latex(biss1))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(40, bissstr)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(41, latex(biss2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(42, latex(pp))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(2, format='notprovided', _p_=G4)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(43, latex(lineL3))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(44, latex(lineL4))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(45, latex(lined1))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(46, latex(lined2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(47, latex(lineNE))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(48, latex(lineNF))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(49, latex(lineEF))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(50, latex(dNL1))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(51, latex(n(dNL1, digits=4)))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(52, latex(lineL1norm))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(53, intercept)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(3, format='notprovided', _p_=G5)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(54, latex(d))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(55, latex(newL(cc=cc1)))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(56, latex(newL(cc=cc2)))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(57, latex(lineLp))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(58, latex(lineLq))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(59, latex(lineLrt(cc=cc3)))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(60, latex(lineLrt(cc=cc4)))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(61, latex(angL1L2))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(62, latex(round(angL1L2*180/pi)))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(63, angNstr)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(64, angONstr)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(65, latex(biss3))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.inline(66, latex(biss4))
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(4, format='notprovided', _p_=G6)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(5, format='notprovided', _p_=G7)
except:
 _st_.goboom(674)
try:
 _st_.current_tex_line = 674
 _st_.plot(6, format='notprovided', _p_=G8)
except:
 _st_.goboom(674)
_st_.endofdoc()
